{"version":3,"file":"form-JvG0YwJe.js","sources":["../src/utils/form.ts"],"sourcesContent":["import type { ReactiveController, ReactiveControllerHost } from 'lit';\nimport type { FlpFormControl } from './flippico-element.js';\nimport type { FlpButton } from '../components/flp-button/flp-button.js';\n\n//\n// We store a WeakMap of forms + controls so we can keep references to all Shoelace controls within a given form. As\n// elements connect and disconnect to/from the DOM, their containing form is used as the key and the form control is\n// added and removed from the form's set, respectively.\n//\nexport const formCollections: WeakMap<HTMLFormElement, Set<FlpFormControl>> = new WeakMap();\n\n//\n// We store a WeakMap of reportValidity() overloads so we can override it when form controls connect to the DOM and\n// restore the original behavior when they disconnect.\n//\nconst reportValidityOverloads: WeakMap<HTMLFormElement, () => boolean> = new WeakMap();\nconst checkValidityOverloads: WeakMap<HTMLFormElement, () => boolean> = new WeakMap();\n\n//\n// We store a Set of controls that users have interacted with. This allows us to determine the interaction state\n// without littering the DOM with additional data attributes.\n//\nconst userInteractedControls: WeakSet<FlpFormControl> = new WeakSet();\n\n//\n// We store a WeakMap of interactions for each form control so we can track when all conditions are met for validation.\n//\nconst interactions = new WeakMap<FlpFormControl, string[]>();\n\nexport interface FormControlControllerOptions {\n  /** A function that returns the form containing the form control. */\n  form: (input: FlpFormControl) => HTMLFormElement | null;\n  /** A function that returns the form control's name, which will be submitted with the form data. */\n  name: (input: FlpFormControl) => string;\n  /** A function that returns the form control's current value. */\n  value: (input: FlpFormControl) => unknown | unknown[];\n  /** A function that returns the form control's default value. */\n  defaultValue: (input: FlpFormControl) => unknown | unknown[];\n  /** A function that returns the form control's current disabled state. If disabled, the value won't be submitted. */\n  disabled: (input: FlpFormControl) => boolean;\n  /**\n   * A function that maps to the form control's reportValidity() function. When the control is invalid, this will\n   * prevent submission and trigger the browser's constraint violation warning.\n   */\n  reportValidity: (input: FlpFormControl) => boolean;\n\n  /**\n   * A function that maps to the form control's `checkValidity()` function. When the control is invalid, this will return false.\n   *   this is helpful is you want to check validation without triggering the native browser constraint violation warning.\n   */\n  checkValidity: (input: FlpFormControl) => boolean;\n  /** A function that sets the form control's value */\n  setValue: (input: FlpFormControl, value: unknown) => void;\n  /**\n   * An array of event names to listen to. When all events in the list are emitted, the control will receive validity\n   * states such as user-valid and user-invalid.user interacted validity states. */\n  assumeInteractionOn: string[];\n}\n\n/** A reactive controller to allow form controls to participate in form submission, validation, etc. */\nexport class FormControlController implements ReactiveController {\n  host: FlpFormControl & ReactiveControllerHost;\n  form?: HTMLFormElement | null;\n  options: FormControlControllerOptions;\n\n  constructor(host: ReactiveControllerHost & FlpFormControl, options?: Partial<FormControlControllerOptions>) {\n    (this.host = host).addController(this);\n    this.options = {\n      form: input => {\n        // If there's a form attribute, use it to find the target form by id\n        // Controls may not always reflect the 'form' property. For example, `<flp-button>` doesn't reflect.\n        const formId = input.form;\n\n        if (formId) {\n          const root = input.getRootNode() as Document | ShadowRoot;\n\n          const form = root.getElementById(formId);\n\n          if (form) {\n            return form as HTMLFormElement;\n          }\n        }\n\n        return input.closest('form');\n      },\n      name: input => input.name,\n      value: input => input.value,\n      defaultValue: input => input.defaultValue,\n      disabled: input => input.disabled ?? false,\n      reportValidity: input => (typeof input.reportValidity === 'function' ? input.reportValidity() : true),\n      checkValidity: input => (typeof input.checkValidity === 'function' ? input.checkValidity() : true),\n      // @ts-ignore\n      setValue: (input, value: string) => (input.value = value),\n      assumeInteractionOn: ['flp-input'],\n      ...options\n    };\n  }\n\n  hostConnected() {\n    const form = this.options.form(this.host);\n\n    if (form) {\n      this.attachForm(form);\n    }\n\n    // Listen for interactions\n    interactions.set(this.host, []);\n    this.options.assumeInteractionOn.forEach(event => {\n      this.host.addEventListener(event, this.handleInteraction);\n    });\n  }\n\n  hostDisconnected() {\n    this.detachForm();\n\n    // Clean up interactions\n    interactions.delete(this.host);\n    this.options.assumeInteractionOn.forEach(event => {\n      this.host.removeEventListener(event, this.handleInteraction);\n    });\n  }\n\n  hostUpdated() {\n    const form = this.options.form(this.host);\n\n    // Detach if the form no longer exists\n    if (!form) {\n      this.detachForm();\n    }\n\n    // If the form has changed, reattach it\n    if (form && this.form !== form) {\n      this.detachForm();\n      this.attachForm(form);\n    }\n\n    if (this.host.hasUpdated) {\n      this.setValidity(this.host.validity.valid);\n    }\n  }\n\n  private attachForm(form?: HTMLFormElement) {\n    if (form) {\n      this.form = form;\n\n      // Add this element to the form's collection\n      if (formCollections.has(this.form)) {\n        formCollections.get(this.form)!.add(this.host);\n      } else {\n        formCollections.set(this.form, new Set<FlpFormControl>([this.host]));\n      }\n\n      this.form.addEventListener('formdata', this.handleFormData);\n      this.form.addEventListener('submit', this.handleFormSubmit);\n      this.form.addEventListener('reset', this.handleFormReset);\n\n      // Overload the form's reportValidity() method so it looks at Shoelace form controls\n      if (!reportValidityOverloads.has(this.form)) {\n        reportValidityOverloads.set(this.form, this.form.reportValidity);\n        this.form.reportValidity = () => this.reportFormValidity();\n      }\n\n      // Overload the form's checkValidity() method so it looks at Shoelace form controls\n      if (!checkValidityOverloads.has(this.form)) {\n        checkValidityOverloads.set(this.form, this.form.checkValidity);\n        this.form.checkValidity = () => this.checkFormValidity();\n      }\n    } else {\n      this.form = undefined;\n    }\n  }\n\n  private detachForm() {\n    if (!this.form) return;\n\n    const formCollection = formCollections.get(this.form);\n\n    if (!formCollection) {\n      return;\n    }\n\n    // Remove this host from the form's collection\n    formCollection.delete(this.host);\n\n    // Check to make sure there's no other form controls in the collection. If we do this\n    // without checking if any other controls are still in the collection, then we will wipe out the\n    // validity checks for all other elements.\n    // see: https://github.com/shoelace-style/shoelace/issues/1703\n    if (formCollection.size <= 0) {\n      this.form.removeEventListener('formdata', this.handleFormData);\n      this.form.removeEventListener('submit', this.handleFormSubmit);\n      this.form.removeEventListener('reset', this.handleFormReset);\n\n      // Remove the overload and restore the original method\n      if (reportValidityOverloads.has(this.form)) {\n        this.form.reportValidity = reportValidityOverloads.get(this.form)!;\n        reportValidityOverloads.delete(this.form);\n      }\n\n      if (checkValidityOverloads.has(this.form)) {\n        this.form.checkValidity = checkValidityOverloads.get(this.form)!;\n        checkValidityOverloads.delete(this.form);\n      }\n\n      // So it looks weird here to not always set the form to undefined. But I _think_ if we unattach this.form here,\n      // we end up in this fun spot where future validity checks don't have a reference to the form validity handler.\n      // First form element in sets the validity handler. So we can't clean up `this.form` until there are no other form elements in the form.\n      this.form = undefined;\n    }\n  }\n\n  private handleFormData = (event: FormDataEvent) => {\n    const disabled = this.options.disabled(this.host);\n    const name = this.options.name(this.host);\n    const value = this.options.value(this.host);\n\n    // For buttons, we only submit the value if they were the submitter. This is currently done in doAction() by\n    // injecting the name/value on a temporary button, so we can just skip them here.\n    const isButton = this.host.tagName.toLowerCase() === 'flp-button';\n\n    if (!disabled && !isButton && typeof name === 'string' && name.length > 0 && typeof value !== 'undefined') {\n      if (Array.isArray(value)) {\n        (value as unknown[]).forEach(val => {\n          event.formData.append(name, (val as string | number | boolean).toString());\n        });\n      } else {\n        event.formData.append(name, (value as string | number | boolean).toString());\n      }\n    }\n  };\n\n  private handleFormSubmit = (event: Event) => {\n    const disabled = this.options.disabled(this.host);\n    const reportValidity = this.options.reportValidity;\n\n    // Update the interacted state for all controls when the form is submitted\n    if (this.form && !this.form.noValidate) {\n      formCollections.get(this.form)?.forEach(control => {\n        this.setUserInteracted(control, true);\n      });\n    }\n\n    if (this.form && !this.form.noValidate && !disabled && !reportValidity(this.host)) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    }\n  };\n\n  private handleFormReset = () => {\n    this.options.setValue(this.host, this.options.defaultValue(this.host));\n    this.setUserInteracted(this.host, false);\n    interactions.set(this.host, []);\n  };\n\n  private handleInteraction = (event: Event) => {\n    const emittedEvents = interactions.get(this.host)!;\n\n    if (!emittedEvents.includes(event.type)) {\n      emittedEvents.push(event.type);\n    }\n\n    // Mark it as user-interacted as soon as all associated events have been emitted\n    if (emittedEvents.length === this.options.assumeInteractionOn.length) {\n      this.setUserInteracted(this.host, true);\n    }\n  };\n\n  private checkFormValidity = () => {\n    //\n    // This is very similar to the `reportFormValidity` function, but it does not trigger native constraint validation\n    // Allow the user to simply check if the form is valid and handling validity in their own way.\n    //\n    // We preserve the original method in a WeakMap, but we don't call it from the overload because that would trigger\n    // validations in an unexpected order. When the element disconnects, we revert to the original behavior. This won't\n    // be necessary once we can use ElementInternals.\n    //\n    // Note that we're also honoring the form's novalidate attribute.\n    //\n    if (this.form && !this.form.noValidate) {\n      // This seems sloppy, but checking all elements will cover native inputs, Shoelace inputs, and other custom\n      // elements that support the constraint validation API.\n      const elements = this.form.querySelectorAll<HTMLInputElement>('*');\n\n      for (const element of elements) {\n        if (typeof element.checkValidity === 'function') {\n          if (!element.checkValidity()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  private reportFormValidity = () => {\n    //\n    // Shoelace form controls work hard to act like regular form controls. They support the Constraint Validation API\n    // and its associated methods such as setCustomValidity() and reportValidity(). However, the HTMLFormElement also\n    // has a reportValidity() method that will trigger validation on all child controls. Since we're not yet using\n    // ElementInternals, we need to overload this method so it looks for any element with the reportValidity() method.\n    //\n    // We preserve the original method in a WeakMap, but we don't call it from the overload because that would trigger\n    // validations in an unexpected order. When the element disconnects, we revert to the original behavior. This won't\n    // be necessary once we can use ElementInternals.\n    //\n    // Note that we're also honoring the form's novalidate attribute.\n    //\n    if (this.form && !this.form.noValidate) {\n      // This seems sloppy, but checking all elements will cover native inputs, Shoelace inputs, and other custom\n      // elements that support the constraint validation API.\n      const elements = this.form.querySelectorAll<HTMLInputElement>('*');\n\n      for (const element of elements) {\n        if (typeof element.reportValidity === 'function') {\n          if (!element.reportValidity()) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  private setUserInteracted(el: FlpFormControl, hasInteracted: boolean) {\n    if (hasInteracted) {\n      userInteractedControls.add(el);\n    } else {\n      userInteractedControls.delete(el);\n    }\n\n    el.requestUpdate();\n  }\n\n  private doAction(type: 'submit' | 'reset', submitter?: HTMLInputElement | FlpButton) {\n    if (this.form) {\n      const button = document.createElement('button');\n      button.type = type;\n      button.style.position = 'absolute';\n      button.style.width = '0';\n      button.style.height = '0';\n      button.style.clipPath = 'inset(50%)';\n      button.style.overflow = 'hidden';\n      button.style.whiteSpace = 'nowrap';\n\n      // Pass name, value, and form attributes through to the temporary button\n      if (submitter) {\n        button.name = submitter.name;\n        button.value = submitter.value;\n\n        ['formaction', 'formenctype', 'formmethod', 'formnovalidate', 'formtarget'].forEach(attr => {\n          if (submitter.hasAttribute(attr)) {\n            button.setAttribute(attr, submitter.getAttribute(attr)!);\n          }\n        });\n      }\n\n      this.form.append(button);\n      button.click();\n      button.remove();\n    }\n  }\n\n  /** Returns the associated `<form>` element, if one exists. */\n  getForm() {\n    return this.form ?? null;\n  }\n\n  /** Resets the form, restoring all the control to their default value */\n  reset(submitter?: HTMLInputElement | FlpButton) {\n    this.doAction('reset', submitter);\n  }\n\n  /** Submits the form, triggering validation and form data injection. */\n  submit(submitter?: HTMLInputElement | FlpButton) {\n    // Calling form.submit() bypasses the submit event and constraint validation. To prevent this, we can inject a\n    // native submit button into the form, \"click\" it, then remove it to simulate a standard form submission.\n    this.doAction('submit', submitter);\n  }\n\n  /**\n   * Synchronously sets the form control's validity. Call this when you know the future validity but need to update\n   * the host element immediately, i.e. before Lit updates the component in the next update.\n   */\n  setValidity(isValid: boolean) {\n    const host = this.host;\n    const hasInteracted = Boolean(userInteractedControls.has(host));\n    const required = Boolean(host.required);\n\n    //\n    // We're mapping the following \"states\" to data attributes. In the future, we can use ElementInternals.states to\n    // create a similar mapping, but instead of [data-invalid] it will look like :--invalid.\n    //\n    // See this RFC for more details: https://github.com/shoelace-style/shoelace/issues/1011\n    //\n    host.toggleAttribute('data-required', required);\n    host.toggleAttribute('data-optional', !required);\n    host.toggleAttribute('data-invalid', !isValid);\n    host.toggleAttribute('data-valid', isValid);\n    host.toggleAttribute('data-user-invalid', !isValid && hasInteracted);\n    host.toggleAttribute('data-user-valid', isValid && hasInteracted);\n  }\n\n  /**\n   * Updates the form control's validity based on the current value of `host.validity.valid`. Call this when anything\n   * that affects constraint validation changes so the component receives the correct validity states.\n   */\n  updateValidity() {\n    const host = this.host;\n    this.setValidity(host.validity.valid);\n  }\n\n  /**\n   * Dispatches a non-bubbling, cancelable custom event of type `flp-invalid`.\n   * If the `flp-invalid` event will be cancelled then the original `invalid`\n   * event (which may have been passed as argument) will also be cancelled.\n   * If no original `invalid` event has been passed then the `flp-invalid`\n   * event will be cancelled before being dispatched.\n   */\n  emitInvalidEvent(originalInvalidEvent?: Event) {\n    const slInvalidEvent = new CustomEvent<Record<PropertyKey, never>>('flp-invalid', {\n      bubbles: false,\n      composed: false,\n      cancelable: true,\n      detail: {}\n    });\n\n    if (!originalInvalidEvent) {\n      slInvalidEvent.preventDefault();\n    }\n\n    if (!this.host.dispatchEvent(slInvalidEvent)) {\n      originalInvalidEvent?.preventDefault();\n    }\n  }\n}\n\n/*\n * Predefined common validity states.\n * All of them are read-only.\n */\n\n// A validity state object that represents `valid`\nexport const validValidityState: ValidityState = Object.freeze({\n  badInput: false,\n  customError: false,\n  patternMismatch: false,\n  rangeOverflow: false,\n  rangeUnderflow: false,\n  stepMismatch: false,\n  tooLong: false,\n  tooShort: false,\n  typeMismatch: false,\n  valid: true,\n  valueMissing: false\n});\n\n// A validity state object that represents `value missing`\nexport const valueMissingValidityState: ValidityState = Object.freeze({\n  ...validValidityState,\n  valid: false,\n  valueMissing: true\n});\n\n// A validity state object that represents a custom error\nexport const customErrorValidityState: ValidityState = Object.freeze({\n  ...validValidityState,\n  valid: false,\n  customError: true\n});"],"names":["formCollections","reportValidityOverloads","checkValidityOverloads","userInteractedControls","interactions","FormControlController","host","options","event","disabled","name","value","isButton","val","_a","reportValidity","control","emittedEvents","elements","element","input","formId","form","formCollection","el","hasInteracted","type","submitter","button","attr","isValid","required","originalInvalidEvent","slInvalidEvent","validValidityState"],"mappings":"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"}