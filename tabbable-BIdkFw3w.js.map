{"version":3,"file":"tabbable-BIdkFw3w.js","sources":["../src/utils/tabbable.ts"],"sourcesContent":["// Cached compute style calls. This is specifically for browsers that dont support `checkVisibility()`.\n// computedStyle calls are \"live\" so they only need to be retrieved once for an element.\nconst computedStyleMap = new WeakMap<Element, CSSStyleDeclaration>();\n\nfunction isVisible(el: HTMLElement): boolean {\n  // This is the fastest check, but isn't supported in Safari.\n  if (typeof el.checkVisibility === 'function') {\n    // Opacity is focusable, visibility is not.\n    return el.checkVisibility({ checkOpacity: false, checkVisibilityCSS: true });\n  }\n\n  // Fallback \"polyfill\" for \"checkVisibility\"\n  let computedStyle: undefined | CSSStyleDeclaration = computedStyleMap.get(el);\n\n  if (!computedStyle) {\n    computedStyle = window.getComputedStyle(el, null);\n    computedStyleMap.set(el, computedStyle);\n  }\n\n  return computedStyle.visibility !== 'hidden' && computedStyle.display !== 'none';\n}\n\n/** Determines if the specified element is tabbable using heuristics inspired by https://github.com/focus-trap/tabbable */\nfunction isTabbable(el: HTMLElement) {\n  const tag = el.tagName.toLowerCase();\n\n  const tabindex = Number(el.getAttribute('tabindex'));\n  const hasTabindex = el.hasAttribute('tabindex');\n\n  // elements with a tabindex attribute that is either NaN or <= -1 are not tabbable\n  if (hasTabindex && (isNaN(tabindex) || tabindex <= -1)) {\n    return false;\n  }\n\n  // Elements with a disabled attribute are not tabbable\n  if (el.hasAttribute('disabled')) {\n    return false;\n  }\n\n  // If any parents have \"inert\", we aren't \"tabbable\"\n  if (el.closest('[inert]')) {\n    return false;\n  }\n\n  // Elements with a disabled attribute are not tabbable\n  if (el.hasAttribute('disabled')) {\n    return false;\n  }\n\n  // Radios without a checked attribute are not tabbable\n  if (tag === 'input' && el.getAttribute('type') === 'radio' && !el.hasAttribute('checked')) {\n    return false;\n  }\n\n  if (!isVisible(el)) {\n    return false;\n  }\n\n  // Audio and video elements with the controls attribute are tabbable\n  if ((tag === 'audio' || tag === 'video') && el.hasAttribute('controls')) {\n    return true;\n  }\n\n  // Elements with a tabindex other than -1 are tabbable\n  if (el.hasAttribute('tabindex')) {\n    return true;\n  }\n\n  // Elements with a contenteditable attribute are tabbable\n  if (el.hasAttribute('contenteditable') && el.getAttribute('contenteditable') !== 'false') {\n    return true;\n  }\n\n  // At this point, the following elements are considered tabbable\n  return ['button', 'input', 'select', 'textarea', 'a', 'audio', 'video', 'summary', 'iframe'].includes(tag);\n}\n\n/**\n * Returns the first and last bounding elements that are tabbable. This is more performant than checking every single\n * element because it short-circuits after finding the first and last ones.\n */\nexport function getTabbableBoundary(root: HTMLElement | ShadowRoot) {\n  const tabbableElements = getTabbableElements(root);\n\n  // Find the first and last tabbable elements\n  const start = tabbableElements[0] ?? null;\n  const end = tabbableElements[tabbableElements.length - 1] ?? null;\n\n  return { start, end };\n}\n\n/**\n * This looks funky. Basically a slot's children will always be picked up *if* they're within the `root` element.\n * However, there is an edge case when, if the `root` is wrapped by another shadow DOM, it won't grab the children.\n * This fixes that fun edge case.\n */\nfunction getSlottedChildrenOutsideRootElement(slotElement: HTMLSlotElement, root: HTMLElement | ShadowRoot) {\n  return (slotElement.getRootNode({ composed: true }) as ShadowRoot | null)?.host !== root;\n}\n\nexport function getTabbableElements(root: HTMLElement | ShadowRoot) {\n  const walkedEls = new WeakMap();\n  const tabbableElements: HTMLElement[] = [];\n\n  function walk(el: HTMLElement | ShadowRoot) {\n    if (el instanceof Element) {\n      // if the element has \"inert\" we can just no-op it.\n      if (el.hasAttribute('inert') || el.closest('[inert]')) {\n        return;\n      }\n\n      if (walkedEls.has(el)) {\n        return;\n      }\n      walkedEls.set(el, true);\n\n      if (!tabbableElements.includes(el) && isTabbable(el)) {\n        tabbableElements.push(el);\n      }\n\n      if (el instanceof HTMLSlotElement && getSlottedChildrenOutsideRootElement(el, root)) {\n        el.assignedElements({ flatten: true }).forEach((assignedEl: any) => {\n          walk(assignedEl);\n        });\n      }\n\n      if (el.shadowRoot !== null && el.shadowRoot.mode === 'open') {\n        walk(el.shadowRoot);\n      }\n    }\n\n    for (const e of el.children) {\n      walk(e as HTMLElement);\n    }\n  }\n\n  // Collect all elements including the root\n  walk(root);\n\n  // Is this worth having? Most sorts will always add increased overhead. And positive tabindexes shouldn't really be used.\n  // So is it worth being right? Or fast?\n  return tabbableElements.sort((a, b) => {\n    // Make sure we sort by tabindex.\n    const aTabindex = Number(a.getAttribute('tabindex')) || 0;\n    const bTabindex = Number(b.getAttribute('tabindex')) || 0;\n    return bTabindex - aTabindex;\n  });\n}\n"],"names":["computedStyleMap","isVisible","el","computedStyle","isTabbable","tag","tabindex","getTabbableBoundary","root","tabbableElements","getTabbableElements","start","end","getSlottedChildrenOutsideRootElement","slotElement","_a","walkedEls","walk","assignedEl","e","a","b","aTabindex"],"mappings":"AAEA,MAAMA,MAAuB,QAE7B,SAASC,EAAUC,EAA0B,CAE3C,GAAI,OAAOA,EAAG,iBAAoB,WAEhC,OAAOA,EAAG,gBAAgB,CAAE,aAAc,GAAO,mBAAoB,GAAM,EAI7E,IAAIC,EAAiDH,EAAiB,IAAIE,CAAE,EAE5E,OAAKC,IACHA,EAAgB,OAAO,iBAAiBD,EAAI,IAAI,EAChDF,EAAiB,IAAIE,EAAIC,CAAa,GAGjCA,EAAc,aAAe,UAAYA,EAAc,UAAY,MAC5E,CAGA,SAASC,EAAWF,EAAiB,CACnC,MAAMG,EAAMH,EAAG,QAAQ,YAAA,EAEjBI,EAAW,OAAOJ,EAAG,aAAa,UAAU,CAAC,EA4BnD,OA3BoBA,EAAG,aAAa,UAAU,IAG1B,MAAMI,CAAQ,GAAKA,GAAY,KAK/CJ,EAAG,aAAa,UAAU,GAK1BA,EAAG,QAAQ,SAAS,GAKpBA,EAAG,aAAa,UAAU,GAK1BG,IAAQ,SAAWH,EAAG,aAAa,MAAM,IAAM,SAAW,CAACA,EAAG,aAAa,SAAS,GAIpF,CAACD,EAAUC,CAAE,EACR,IAIJG,IAAQ,SAAWA,IAAQ,UAAYH,EAAG,aAAa,UAAU,GAKlEA,EAAG,aAAa,UAAU,GAK1BA,EAAG,aAAa,iBAAiB,GAAKA,EAAG,aAAa,iBAAiB,IAAM,QACxE,GAIF,CAAC,SAAU,QAAS,SAAU,WAAY,IAAK,QAAS,QAAS,UAAW,QAAQ,EAAE,SAASG,CAAG,CAC3G,CAMO,SAASE,EAAoBC,EAAgC,CAClE,MAAMC,EAAmBC,EAAoBF,CAAI,EAG3CG,EAAQF,EAAiB,CAAC,GAAK,KAC/BG,EAAMH,EAAiBA,EAAiB,OAAS,CAAC,GAAK,KAE7D,MAAO,CAAE,MAAAE,EAAO,IAAAC,CAAA,CAClB,CAOA,SAASC,EAAqCC,EAA8BN,EAAgC,CA9F5G,IAAAO,EA+FE,QAAQA,EAAAD,EAAY,YAAY,CAAE,SAAU,EAAA,CAAM,IAA1C,YAAAC,EAAmE,QAASP,CACtF,CAEO,SAASE,EAAoBF,EAAgC,CAClE,MAAMQ,MAAgB,QAChBP,EAAkC,CAAA,EAExC,SAASQ,EAAKf,EAA8B,CAC1C,GAAIA,aAAc,QAAS,CAMzB,GAJIA,EAAG,aAAa,OAAO,GAAKA,EAAG,QAAQ,SAAS,GAIhDc,EAAU,IAAId,CAAE,EAClB,OAEFc,EAAU,IAAId,EAAI,EAAI,EAElB,CAACO,EAAiB,SAASP,CAAE,GAAKE,EAAWF,CAAE,GACjDO,EAAiB,KAAKP,CAAE,EAGtBA,aAAc,iBAAmBW,EAAqCX,EAAIM,CAAI,GAChFN,EAAG,iBAAiB,CAAE,QAAS,EAAA,CAAM,EAAE,QAASgB,GAAoB,CAClED,EAAKC,CAAU,CACjB,CAAC,EAGChB,EAAG,aAAe,MAAQA,EAAG,WAAW,OAAS,QACnDe,EAAKf,EAAG,UAAU,CAEtB,CAEA,UAAWiB,KAAKjB,EAAG,SACjBe,EAAKE,CAAgB,CAEzB,CAGA,OAAAF,EAAKT,CAAI,EAIFC,EAAiB,KAAK,CAACW,EAAGC,IAAM,CAErC,MAAMC,EAAY,OAAOF,EAAE,aAAa,UAAU,CAAC,GAAK,EAExD,OADkB,OAAOC,EAAE,aAAa,UAAU,CAAC,GAAK,GACrCC,CACrB,CAAC,CACH"}