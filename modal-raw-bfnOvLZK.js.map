{"version":3,"file":"modal-raw-bfnOvLZK.js","sources":["../src/utils/active-elements.ts","../src/utils/modal-raw.ts"],"sourcesContent":["/**\n * Use a generator so we can iterate and possibly break early.\n * @example\n *   // to operate like a regular array. This kinda nullifies generator benefits, but worth knowing if you need the whole array.\n *   const allActiveElements = [...activeElements()]\n *\n *   // Early return\n *   for (const activeElement of activeElements()) {\n *     if (<cond>) {\n *       break; // Break the loop, dont need to iterate over the whole array or store an array in memory!\n *     }\n *   }\n */\nexport function* activeElements(activeElement: Element | null = document.activeElement): Generator<Element> {\n  if (activeElement === null || activeElement === undefined) return;\n\n  yield activeElement;\n\n  if ('shadowRoot' in activeElement && activeElement.shadowRoot && activeElement.shadowRoot.mode !== 'closed') {\n    yield* activeElements(activeElement.shadowRoot.activeElement);\n  }\n}\n\nexport function getDeepestActiveElement() {\n  return [...activeElements()].pop();\n}\n","import { getDeepestActiveElement } from './active-elements.js';\nimport { getTabbableElements } from './tabbable.js';\n\nlet activeModals: HTMLElement[] = [];\n\nexport default class ModalRaw {\n  element: HTMLElement;\n  isExternalActivated: boolean;\n  tabDirection: 'forward' | 'backward' = 'forward';\n  currentFocus: HTMLElement | null;\n  previousFocus: HTMLElement | null;\n  elementsWithTabbableControls: string[];\n\n  constructor(element: HTMLElement) {\n    this.element = element;\n\n    this.elementsWithTabbableControls = ['iframe'];\n  }\n\n  /** Activates focus trapping. */\n  activate() {\n    activeModals.push(this.element);\n    document.addEventListener('focusin', this.handleFocusIn);\n    document.addEventListener('keydown', this.handleKeyDown);\n    document.addEventListener('keyup', this.handleKeyUp);\n  }\n\n  /** Deactivates focus trapping. */\n  deactivate() {\n    activeModals = activeModals.filter(modal => modal !== this.element);\n    this.currentFocus = null;\n    document.removeEventListener('focusin', this.handleFocusIn);\n    document.removeEventListener('keydown', this.handleKeyDown);\n    document.removeEventListener('keyup', this.handleKeyUp);\n  }\n\n  /** Determines if this modal element is currently active or not. */\n  isActive() {\n    // The \"active\" modal is always the most recent one shown\n    return activeModals[activeModals.length - 1] === this.element;\n  }\n\n  /** Activates external modal behavior and temporarily disables focus trapping. */\n  activateExternal() {\n    this.isExternalActivated = true;\n  }\n\n  /** Deactivates external modal behavior and re-enables focus trapping. */\n  deactivateExternal() {\n    this.isExternalActivated = false;\n  }\n\n  private checkFocus() {\n    if (this.isActive() && !this.isExternalActivated) {\n      const tabbableElements = getTabbableElements(this.element);\n      if (!this.element.matches(':focus-within')) {\n        const start = tabbableElements[0];\n        const end = tabbableElements[tabbableElements.length - 1];\n        const target = this.tabDirection === 'forward' ? start : end;\n\n        if (typeof target?.focus === 'function') {\n          this.currentFocus = target;\n          target.focus({ preventScroll: false });\n        }\n      }\n    }\n  }\n\n  private handleFocusIn = () => {\n    if (!this.isActive()) return;\n    this.checkFocus();\n  };\n\n  private possiblyHasTabbableChildren(element: HTMLElement) {\n    return (\n      this.elementsWithTabbableControls.includes(element.tagName.toLowerCase()) || element.hasAttribute('controls')\n      // Should we add a data-attribute for people to set just in case they have an element where we don't know if it has possibly tabbable elements?\n    );\n  }\n\n  private handleKeyDown = (event: KeyboardEvent) => {\n    if (event.key !== 'Tab' || this.isExternalActivated) return;\n    if (!this.isActive()) return;\n\n    // Because sometimes focus can actually be taken over from outside sources,\n    // we don't want to rely on `this.currentFocus`. Instead we check the actual `activeElement` and\n    // recurse through shadowRoots.\n    const currentActiveElement = getDeepestActiveElement();\n    this.previousFocus = currentActiveElement as HTMLElement | null;\n\n    if (this.previousFocus && this.possiblyHasTabbableChildren(this.previousFocus)) {\n      return;\n    }\n\n    if (event.shiftKey) {\n      this.tabDirection = 'backward';\n    } else {\n      this.tabDirection = 'forward';\n    }\n\n    const tabbableElements = getTabbableElements(this.element);\n\n    let currentFocusIndex = tabbableElements.findIndex(el => el === currentActiveElement);\n\n    this.previousFocus = this.currentFocus;\n\n    if (currentFocusIndex === -1) {\n      this.currentFocus = tabbableElements[0];\n\n      // We don't call event.preventDefault() here because it messes with tabbing to the <iframe> controls.\n      // We just wait until the current focus is no longer an element with possible hidden controls.\n      if (Boolean(this.previousFocus) && this.possiblyHasTabbableChildren(this.previousFocus!)) {\n        return;\n      }\n\n      event.preventDefault();\n      this.currentFocus?.focus({ preventScroll: false });\n      return;\n    }\n\n    const addition = this.tabDirection === 'forward' ? 1 : -1;\n\n    if (currentFocusIndex + addition >= tabbableElements.length) {\n      currentFocusIndex = 0;\n    } else if (currentFocusIndex + addition < 0) {\n      currentFocusIndex = tabbableElements.length - 1;\n    } else {\n      currentFocusIndex += addition;\n    }\n\n    this.previousFocus = this.currentFocus;\n    const nextFocus = /** @type {HTMLElement} */ tabbableElements[currentFocusIndex];\n\n    // This is a special case. We need to make sure we're not calling .focus() if we're already focused on an element\n    // that possibly has \"controls\"\n    if (this.tabDirection === 'backward') {\n      if (this.previousFocus && this.possiblyHasTabbableChildren(this.previousFocus)) {\n        return;\n      }\n    }\n\n    if (nextFocus && this.possiblyHasTabbableChildren(nextFocus)) {\n      return;\n    }\n\n    event.preventDefault();\n    this.currentFocus = nextFocus;\n    this.currentFocus?.focus({ preventScroll: true });\n\n    setTimeout(() => this.checkFocus());\n  };\n\n  private handleKeyUp = () => {\n    this.tabDirection = 'forward';\n  };\n}\n"],"names":["activeElements","activeElement","getDeepestActiveElement","activeModals","ModalRaw","element","event","currentActiveElement","tabbableElements","getTabbableElements","currentFocusIndex","el","_a","addition","nextFocus","_b","modal","start","end","target"],"mappings":"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"}